{% extends 'base.html' %}
{% block title %}Analysis - PestiGuard{% endblock %}
{% block content %}
  <div class="card mb-3">
    <div class="card-body">
      <h5 class="card-title mb-3">Run Analysis</h5>
      <form method="post" action="{{ url_for('analysis_preview') }}" enctype="multipart/form-data" class="row g-3" id="analysis-form">
        <input type="hidden" name="captured_data" id="captured_data">
        <div class="col-12 col-lg-4">
          <label class="form-label">Upload image</label>
          <input type="file" class="form-control" name="image" accept="image/*" capture="environment">
          <div class="form-text">Choose a photo (mobile will prompt camera by default).</div>
        </div>
        <div class="col-12 col-lg-8">
          <div class="border rounded p-2">
            <div class="d-flex justify-content-between align-items-center mb-2">
              <div class="fw-semibold">Or capture from camera</div>
              <div>
                <button type="button" class="btn btn-sm btn-outline-secondary" id="startCamBtn">Start camera</button>
                <button type="button" class="btn btn-sm btn-outline-secondary" id="stopCamBtn" disabled>Stop</button>
                <button type="button" class="btn btn-sm btn-primary" id="captureBtn" disabled>Capture</button>
              </div>
            </div>
            <div class="row g-2">
              <div class="col-12 col-md-6">
                <video id="video" playsinline class="w-100 rounded border" style="max-height: 240px; background: #000;"></video>
              </div>
              <div class="col-12 col-md-6">
                <canvas id="canvas" class="w-100 rounded border" style="max-height: 240px;"></canvas>
              </div>
            </div>
            <div class="form-text">Click Capture to freeze a frame. Submitting will use the captured image if present.</div>
          </div>
        </div>
        <div class="col-12">
          <div class="form-check">
            <input class="form-check-input" type="checkbox" name="normalize" id="normalize">
            <label class="form-check-label" for="normalize">
              Use background normalization (auto from corner)
            </label>
          </div>
        </div>
        <div class="col-12 d-flex justify-content-end">
          <button type="submit" class="btn btn-primary">Analyze</button>
        </div>
      </form>
    </div>
  </div>

  {% if image_path and results %}
  <div class="row g-3">
    <div class="col-12 col-lg-6">
      <div class="card">
        <div class="card-body">
          <h6 class="mb-3">Uploaded image</h6>
          <div class="position-relative d-inline-block">
            <img id="analyzed-img" src="/{{ image_path }}" class="img-fluid rounded border" alt="uploaded">
            {% for r in results %}
              {% set left_pct = (r.x / width * 100.0) %}
              {% set top_pct = (r.y / height * 100.0) %}
              <div class="position-absolute translate-middle"
                   data-left-pct="{{ '%.2f'|format(left_pct) }}"
                   data-top-pct="{{ '%.2f'|format(top_pct) }}">
                <span class="d-inline-block rounded-circle" style="width: 14px; height: 14px; background: var(--bs-primary); border: 2px solid #fff; box-shadow: 0 0 0 2px rgba(var(--bs-primary-rgb), .5);"></span>
              </div>
            {% endfor %}
          </div>
          <div class="small text-muted mt-2">Markers show the N sampling points used (center + 4 neighbors per point).</div>
        </div>
      </div>
    </div>
    <div class="col-12 col-lg-6">
      <div class="card">
        <div class="card-body">
          <h6 class="mb-3">Results</h6>
          <div class="table-responsive">
            <table class="table table-sm align-middle">
              <thead>
                <tr>
                  <th>Pesticide</th>
                  <th class="text-end">RGB total</th>
                  <th class="text-end">Concentration</th>
                  <th class="text-end">Level</th>
                </tr>
              </thead>
              <tbody>
                {% for r in results %}
                <tr>
                  <td>{{ r.pesticide_name }}</td>
                  <td class="text-end">{{ r.rgb_sum }}</td>
                  <td class="text-end">{{ '%.2f'|format(r.concentration) }}</td>
                  <td class="text-end">
                    {% set badge = 'success' if r.level == 'Low' else ('warning' if r.level == 'Medium' else ('danger' if r.level == 'High' else 'secondary')) %}
                    <span class="badge bg-{{ badge }}">{{ r.level }}</span>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
  {% endif %}
  {% if image_path and points and not results %}
  <div class="card">
    <div class="card-body">
      <h6 class="mb-3">Adjust sampling points</h6>
      <div class="position-relative d-inline-block" id="preview-container">
        <img id="preview-img" src="/{{ image_path }}" class="img-fluid rounded border" alt="preview" data-img-width="{{ width }}" data-img-height="{{ height }}">
        {% for p in points %}
          {% set left_pct = (p.x / width * 100.0) %}
          {% set top_pct = (p.y / height * 100.0) %}
          <div class="drag-point position-absolute translate-middle"
               data-index="{{ loop.index0 }}"
               data-left-pct="{{ '%.2f'|format(left_pct) }}"
               data-top-pct="{{ '%.2f'|format(top_pct) }}">
            <span class="d-inline-block rounded-circle" style="width: 16px; height: 16px; background: var(--bs-danger); border: 2px solid #fff; box-shadow: 0 0 0 2px rgba(var(--bs-danger-rgb), .5); cursor: grab;"></span>
          </div>
        {% endfor %}
      </div>
      <form method="post" action="{{ url_for('analysis_compute') }}" class="mt-3 d-flex flex-wrap gap-2" id="compute-form">
        <input type="hidden" name="points_json" id="points_json">
        <input type="hidden" name="image_path" value="{{ image_path }}">
        <div class="form-check">
          <input class="form-check-input" type="checkbox" name="normalize" id="normalize2">
          <label class="form-check-label" for="normalize2">
            Use background normalization (auto from corner)
          </label>
        </div>
        <div class="ms-auto">
          <button type="button" class="btn btn-outline-secondary btn-sm" id="distributeBtn">Distribute evenly</button>
          <button type="submit" class="btn btn-primary">Analyze</button>
        </div>
      </form>
    </div>
  </div>
  <script>
    (function() {
      const img = document.getElementById('preview-img');
      const container = document.getElementById('preview-container');
      const dots = Array.from(container.querySelectorAll('.drag-point'));
      const W = parseInt(img.getAttribute('data-img-width'), 10) || (img.naturalWidth || 0);
      const H = parseInt(img.getAttribute('data-img-height'), 10) || (img.naturalHeight || 0);
      // Initialize positions for any elements with data-left-pct/top-pct
      document.querySelectorAll('[data-left-pct][data-top-pct]').forEach(function(el){
        const lp = parseFloat(el.getAttribute('data-left-pct'));
        const tp = parseFloat(el.getAttribute('data-top-pct'));
        if (!Number.isNaN(lp) && !Number.isNaN(tp)) {
          el.style.left = lp.toFixed(2) + '%';
          el.style.top = tp.toFixed(2) + '%';
        }
      });
      let points = dots.map(dot => {
        const leftPct = parseFloat(dot.style.left) || 0;
        const topPct = parseFloat(dot.style.top) || 0;
        return {
          x: Math.round(W * leftPct / 100),
          y: Math.round(H * topPct / 100)
        };
      });

      function updateHidden() {
        const out = dots.map((el, i) => points[i]);
        document.getElementById('points_json').value = JSON.stringify(out);
      }

      function percentToPx(leftPct, topPct) {
        const rect = img.getBoundingClientRect();
        return {
          x: leftPct / 100 * W,
          y: topPct / 100 * H
        };
      }
      function pxToPercent(x, y) {
        return {
          left: (x / W * 100),
          top: (y / H * 100)
        };
      }
      function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

      function makeDraggable(dot) {
        let dragging = false;
        let idx = parseInt(dot.dataset.index, 10);
        function onDown(e) {
          e.preventDefault();
          dragging = true;
          dot.style.cursor = 'grabbing';
        }
        function onMove(e) {
          if (!dragging) return;
          const rect = img.getBoundingClientRect();
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;
          const rx = clamp(clientX - rect.left, 0, rect.width);
          const ry = clamp(clientY - rect.top, 0, rect.height);
          // Convert from display px to image px
          const x = rx / rect.width * W;
          const y = ry / rect.height * H;
          points[idx].x = Math.round(x);
          points[idx].y = Math.round(y);
          const pct = pxToPercent(points[idx].x, points[idx].y);
          dot.style.left = pct.left.toFixed(2) + '%';
          dot.style.top = pct.top.toFixed(2) + '%';
        }
        function onUp(e) {
          dragging = false;
          dot.style.cursor = 'grab';
          updateHidden();
        }
        dot.addEventListener('mousedown', onDown);
        dot.addEventListener('touchstart', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('touchmove', onMove);
        window.addEventListener('mouseup', onUp);
        window.addEventListener('touchend', onUp);
      }

      dots.forEach(makeDraggable);
      updateHidden();

      document.getElementById('distributeBtn')?.addEventListener('click', function() {
        const rect = img.getBoundingClientRect();
        const n = dots.length;
        const y = Math.round(H / 2);
        for (let i = 0; i < n; i++) {
          const x = Math.round((i + 1) * (W / (n + 1)));
          points[i].x = x; points[i].y = y;
          const pct = pxToPercent(x, y);
          dots[i].style.left = pct.left.toFixed(2) + '%';
          dots[i].style.top = pct.top.toFixed(2) + '%';
        }
        updateHidden();
      });
    })();
  </script>
  {% endif %}
  <script>
    (function() {
      // Apply left/top styles for any elements that carry percentage data attributes
      document.querySelectorAll('[data-left-pct][data-top-pct]').forEach(function(el){
        const lp = parseFloat(el.getAttribute('data-left-pct'));
        const tp = parseFloat(el.getAttribute('data-top-pct'));
        if (!Number.isNaN(lp) && !Number.isNaN(tp)) {
          el.style.left = lp.toFixed(2) + '%';
          el.style.top = tp.toFixed(2) + '%';
        }
      });
    })();
  </script>
  <script>
    (function() {
      const startBtn = document.getElementById('startCamBtn');
      const stopBtn = document.getElementById('stopCamBtn');
      const captureBtn = document.getElementById('captureBtn');
      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');
      const hiddenInput = document.getElementById('captured_data');
      let stream = null;

      async function startCamera() {
        try {
          stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
          video.srcObject = stream;
          await video.play();
          startBtn.disabled = true;
          stopBtn.disabled = false;
          captureBtn.disabled = false;
        } catch (e) {
          alert('Camera access failed. Please allow camera permissions or use Upload.');
        }
      }
      function stopCamera() {
        if (stream) {
          stream.getTracks().forEach(t => t.stop());
          stream = null;
        }
        video.pause();
        video.srcObject = null;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        captureBtn.disabled = true;
      }
      function captureFrame() {
        const w = video.videoWidth || 640;
        const h = video.videoHeight || 480;
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, w, h);
        const dataUrl = canvas.toDataURL('image/png');
        hiddenInput.value = dataUrl;
      }
      startBtn?.addEventListener('click', startCamera);
      stopBtn?.addEventListener('click', stopCamera);
      captureBtn?.addEventListener('click', captureFrame);
      window.addEventListener('beforeunload', stopCamera);
    })();
  </script>
{% endblock %}


